/**
 * 3D Model Export API Route
 * Handles server-side 3D model export operations
 */

import { NextRequest, NextResponse } from 'next/server';
import { Model3DExportOptions } from '@/types/export';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { options, modelData } = body as {
      options: Model3DExportOptions;
      modelData: {
        vertices: number[];
        normals: number[];
        colors: number[];
        indices: number[];
      };
    };

    if (!modelData) {
      return NextResponse.json(
        { error: 'No model data provided' },
        { status: 400 }
      );
    }

    // Validate options
    if (!options.format || !['gltf', 'obj', 'stl'].includes(options.format)) {
      return NextResponse.json(
        { error: 'Invalid 3D format' },
        { status: 400 }
      );
    }

    let content: string;
    let contentType: string;
    let extension: string;

    switch (options.format) {
      case 'gltf':
        content = generateGLTF(modelData, options);
        contentType = 'model/gltf+json';
        extension = options.binary ? 'glb' : 'gltf';
        break;

      case 'obj':
        content = generateOBJ(modelData, options);
        contentType = 'model/obj';
        extension = 'obj';
        break;

      case 'stl':
        content = generateSTL(modelData, options);
        contentType = 'model/stl';
        extension = 'stl';
        break;

      default:
        return NextResponse.json(
          { error: 'Unsupported format' },
          { status: 400 }
        );
    }

    // Return model with appropriate headers
    return new NextResponse(content, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="export.${extension}"`,
        'Cache-Control': 'no-store'
      }
    });
  } catch (error) {
    console.error('3D model export error:', error);
    return NextResponse.json(
      { error: 'Failed to export 3D model' },
      { status: 500 }
    );
  }
}

// Helper functions for format conversion

function generateGLTF(
  data: { vertices: number[]; normals: number[]; colors: number[]; indices: number[] },
  options: Model3DExportOptions
): string {
  const gltf = {
    asset: {
      version: '2.0',
      generator: 'LAB Visualizer Export Service'
    },
    scenes: [{ nodes: [0] }],
    nodes: [{ mesh: 0 }],
    meshes: [
      {
        primitives: [
          {
            attributes: {
              POSITION: 0,
              ...(options.includeNormals ? { NORMAL: 1 } : {}),
              ...(options.includeColors ? { COLOR_0: 2 } : {})
            },
            indices: 3
          }
        ]
      }
    ],
    accessors: [],
    bufferViews: [],
    buffers: []
  };

  return JSON.stringify(gltf, null, options.binary ? undefined : 2);
}

function generateOBJ(
  data: { vertices: number[]; normals: number[]; colors: number[]; indices: number[] },
  options: Model3DExportOptions
): string {
  let obj = '# Generated by LAB Visualizer\n';
  obj += '# Vertices\n';

  for (let i = 0; i < data.vertices.length; i += 3) {
    const x = data.vertices[i] * options.scale;
    const y = data.vertices[i + 1] * options.scale;
    const z = data.vertices[i + 2] * options.scale;
    obj += `v ${x} ${y} ${z}\n`;
  }

  if (options.includeNormals && data.normals.length > 0) {
    obj += '# Normals\n';
    for (let i = 0; i < data.normals.length; i += 3) {
      obj += `vn ${data.normals[i]} ${data.normals[i + 1]} ${data.normals[i + 2]}\n`;
    }
  }

  obj += '# Faces\n';
  for (let i = 0; i < data.indices.length; i += 3) {
    const v1 = data.indices[i] + 1;
    const v2 = data.indices[i + 1] + 1;
    const v3 = data.indices[i + 2] + 1;

    if (options.includeNormals) {
      obj += `f ${v1}//${v1} ${v2}//${v2} ${v3}//${v3}\n`;
    } else {
      obj += `f ${v1} ${v2} ${v3}\n`;
    }
  }

  return obj;
}

function generateSTL(
  data: { vertices: number[]; normals: number[]; colors: number[]; indices: number[] },
  options: Model3DExportOptions
): string {
  let stl = 'solid LABVisualizer\n';

  for (let i = 0; i < data.indices.length; i += 3) {
    const i1 = data.indices[i] * 3;
    const i2 = data.indices[i + 1] * 3;
    const i3 = data.indices[i + 2] * 3;

    const v1 = [
      data.vertices[i1] * options.scale,
      data.vertices[i1 + 1] * options.scale,
      data.vertices[i1 + 2] * options.scale
    ];
    const v2 = [
      data.vertices[i2] * options.scale,
      data.vertices[i2 + 1] * options.scale,
      data.vertices[i2 + 2] * options.scale
    ];
    const v3 = [
      data.vertices[i3] * options.scale,
      data.vertices[i3 + 1] * options.scale,
      data.vertices[i3 + 2] * options.scale
    ];

    // Calculate normal
    const normal = calculateNormal(v1, v2, v3);

    stl += `  facet normal ${normal[0]} ${normal[1]} ${normal[2]}\n`;
    stl += `    outer loop\n`;
    stl += `      vertex ${v1[0]} ${v1[1]} ${v1[2]}\n`;
    stl += `      vertex ${v2[0]} ${v2[1]} ${v2[2]}\n`;
    stl += `      vertex ${v3[0]} ${v3[1]} ${v3[2]}\n`;
    stl += `    endloop\n`;
    stl += `  endfacet\n`;
  }

  stl += 'endsolid LABVisualizer\n';
  return stl;
}

function calculateNormal(v1: number[], v2: number[], v3: number[]): number[] {
  const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
  const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

  const normal = [
    u[1] * v[2] - u[2] * v[1],
    u[2] * v[0] - u[0] * v[2],
    u[0] * v[1] - u[1] * v[0]
  ];

  const length = Math.sqrt(normal[0] ** 2 + normal[1] ** 2 + normal[2] ** 2);
  return [normal[0] / length, normal[1] / length, normal[2] / length];
}

export async function GET() {
  return NextResponse.json(
    { error: 'Method not allowed. Use POST.' },
    { status: 405 }
  );
}
